<html>
   <link rel="stylesheet" href="style.css">
   <div id = "main">
      <head>
         <title></title>
      </head>
      <body>
         <h1>Курсов проект
            По Разпределени софтуерни архитектури
         </h1>
         <h2 id ="subtitle">Задача: <span id = "">K-means clustering algorithm</span></h2>
         <h2>1.Задание.</h2>
         <p>Задачата е да се реализира паралелна (многонишкова) имплементация на K-means алгоритъма.</p>
         <p>    
         <h2>2.Какво представлява k-means алгоритъма?</h2>
         K-means е много популярен алгоритъм в анализа на данни.
         Той извършва така наречената клъстеризация на вектори.
         Клъстеризацията представлява групиране на наблюдения (n-мерни вектори в общия случай) в определен брой (k) множества(клъстери) така че във всеки един клъстер векторите да бъдат близки един на друг.
         При K-means алгоритъма входните данни се състоят от m ма брой наблюдения(n-мерни вектори). Искаме да ги разделим в k на брой  
         клъстера така, че да минимизираме дисперсията на всяко едно от множествата.
         </p>
         <div id = "algorithm">
            Алгоритъм:
            Първо избираме на случаен принцип k – на брой от наблюденията.
            Те ще служат като прототипи за всеки един от клъстерите.
            Повтаряме p на брой пъти (p e хиперпараметър избран от потребителя)
            {
            <ul>
               <li>Стъпка 1 – За всяко едно то наблюденията намираме на-	близкия клъстер (по Евклидова дистанция до прототипа на 	клъстера) и и добавяме наблюдението към него)</li>
               <li>Стъпка 2 – Пресмятаме наново центровете(means) на всеки от – 	k -на 	брой клъстерите.</li>
            </ul>
            }
         </div>
         <img src="Kmeans.gif">
         <p id = "label">Фиг1. - Анимация на алгоритъма в действие при k = 3.</p>

         <h2>3.Паралелизация на алгоритъма</h2>
         <p>Тъй като стъпка две от алгоритъма зависи от стъпка едно, ще паралелизираме всяка една по отделно, като ще използваме механизъм за синхронизация така че стъпка 2 да започва само ако всички нишки са приключили със стъпка 1.
         За да паралелизираме стъпка едно е достатъчно да разделим наблюденията на равни не-пресичащи се множества и да пресметнем във всяка нишка най близкия клъстер за всяко едно от тях. 
         Например ако имаме 1000 наблюдения и 4ри нишки ще ги разпределим така :
         <ul>
            <li>1: 1-250</li>
            <li>2: 251:500</li>
            <li>3: 501-750</li>
            <li>4: 751-1000</li>
         </ul>
         
         За втората стъпка отново ще разпределим данните по същия начин между нишките.
         При нея обаче проблем -ако използваме споделена структура за да пресмятаме центровете има опасност за race condition. Поради тази причина може да използваме техниката Divide and Conquer. Всяка нишка ще си пази центровете в своя лична несподелена структура. След като всички нишки от втора стъпка приключат работа може да сметнем центровете с просто сумиране на локалните центрове на всяка от нишките. Това ще се случи в главната нишка.</p>
         <h2>4.Синхронизация</h2>
         <p>
         В нашия алгоритъм трябва да подсигурим че на всяка итерация преминаваме към стъпка 2 само ако всички нишки са приключили работа със стъпка 1. И на всяка итерация (освен първата) искаме да започнем стъпка 1 само след като всички нишки са приключили стъпка 2. Много подходящо в случая е да се използва CountdownLatch. Това и правя в моята имплементация.
     	</p>
         <ul>
            <li>CountdownLatch – тред сейф механизъм който действа като 
               бариера с която може някоя нишка изчаква определен брой събития (сваляния на бариерата) и след това продължава работата си.
            </li>
         </ul>
         <h2> 5.Преизползване на нишки</h2>
         <p>
         	Една проста реализация на алгоритъма би създавала p на брой нишки за първата стъпка и p на брой нишки за втората стъпка на всяка итерация от алгоритъма. (<span class = "math">p</span> – брой логически процесори). Това означава че ако сме пуснали алгоритъма с <span class = "math">cnt</span> на брой итерации програмата ни ще създаде общо <span class = "math">2*p*cnt</span> на брой нишки. Това би забавило програмата когато cnt е голямо, защото стартирането на една нишка включва значителен overhead както и системни извиквания. Поради тази причина е добра идея да използваме механизъм който може да преизползва вече създадени нишки. Един такъв механизъм е вграденият в Java ExecutorService. По 
         По този начин ние делегираме стартирането и изпълнението на нишките към него и може да очакваме ускорение на бързодействието когато <span class = "math">cnt</span> е значително число.
     	</p>
         <h2>6.Тестване на алгоритъма</h2>
         <p>Ще тестваме алгоритъма на следната задача.
         Ще вземем снимка и ще намалим броя на цветовете в нея така че да има само 8 главни цвята(така нареченото квантуване по цветове). </p>
      </body>
   </div>
</html>